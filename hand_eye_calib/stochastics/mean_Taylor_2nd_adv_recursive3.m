function MX = mean_Taylor_2nd_adv_recursive3( X, varargin )
%% This function calculates the 2nd order approximation of the mean of a
% bunch of matrices based on the Taylor expansion of the matrix logarithm
% and the definition of mean of a probability density function.

% Input: X is a cell of 4 by 4*n rigid transformation matrices
% Output: M_T1 is the mean of the 1st order approximation of Taylor
% expansion

% Output: MX is the 2nd order approximation of the Taylor expansion
% coder.extrinsic('mean_Taylor_1st_mex');

    n = size(X,2)/4;
    
    if nargin == 2 && ~isempty(varargin{1})
        weight = varargin{1};
        weight = weight./sum(weight);
    else
        weight = ones(1,n)./n;
    end
    
    maxIter = 20;
    if nargin == 3
        maxIter = varargin{2};
    end
    
    M_t1 = mean_1st( X, weight );

    MX = M_t1;

    iter = 1;
    
%     se3 = zeros(6,n);
%     for k=1:n
%         se3(:,k) = tran2vec(X(:,(k-1)*4+1:k*4));
%     end
    
    while iter < maxIter
%         Minv = [MX(1:3,1:3)' -MX(1:3,1:3)'*MX(1:3,4);[0 0 0 1]];
%         AdT = tranAd(Minv);
        LHS = zeros(6,6);
        RHS = zeros(6,1);
        SE3s=MX\X;
%         vs = AdT*se3;
%         vs = vs/AdT;
%         RHS = sum(repmat(weight,6,1).*vs, 1);
        for k=1:n
            SE3 = SE3s(:,(k-1)*4+1:k*4);
            v1 = tran2vec(SE3);
%             v1 = vs(:,k);
            invJ = vec2jacInv(v1);
            RHS = RHS + weight(k).*v1;
            LHS = LHS + weight(k).*invJ;
        end
        xhat = LHS\RHS;
        % update
        try
            MX = MX*vec2tran(xhat);
        catch
            error('');
        end
        if norm(xhat) < 1e-20
            break;
        end
        iter = iter + 1;
    end
    disp(['iter: ', num2str(iter)]);
end

function [M_1, M_hat] = mean_1st( X, weight ) 
    % This function calculates the 1st order approximation of the mean of a
    % bunch of matrices based on the Taylor expansion of the matrix logarithm
    % and the definition of mean of a probability density function.

    % Input: X is a 4 by 4*n rigid transformation matrices
    % Output: M_T1 is the mean of the 1st order approximation of Taylor
    % expansion

    % Change of this m file doesn't automatically change the executable generated by 
    % mean_Taylor_2nd.m
    n =  size(X, 2)/4;

    M_hat = zeros(4);
%     M_1 = zeros(4);

    for i = 1:n
        M_hat = M_hat + weight(i).*X(:,(i-1)*4+1:i*4);
    end

    M_hat = M_hat;  % Note that M_hat doesn't belong to SE(3)

    M_1 = orthog(M_hat);

end
