clc
clear all
close all


%------------------------------------------------------
% optNoise == 1 : Use nstd1
% optNoise == 2 : Use nstd2
optNoise = 2;

% opt == 1 : Use distribution of As and Bs
% opt == 2 : Use distribution of Xs
opt = 2;


%Editable Variables
%------------------------------------------------------

numPair = 60;	%Number of steps

s = [10 20 30 40 50 60 70 80 90 100];

gmean = [0; 0; 0; 0; 0; 0];	%Gaussian Noise Mean

nstd1 = [0 0.001 0.005 0.01 0.02 0.05 0.08 0.1];  %Gaussian Noise standard deviation Range
nstd2 = [0 0.01 0.05 0.1 0.2 0.5 0.8 1];          %Gaussian Noise standard deviation Range

shift = 0; %step shift

model = 1; %noise model

ElipseParam = [10, 10, 10];

trials = 1;

% t2 = (0:(2*pi)/((num + shift)):2*pi);
% twist = 0.0*sin(16*t2);

%%
i = 0; % i that records the number of pairs
markerLie = zeros(1,2); % record the number of pairs and times of simulation when the Lie group method fails
if optNoise == 1
    nstd = nstd1;
elseif optNoise == 2
    nstd = nstd2;
end

dim = size(nstd,2);
N = 100; % Times of simulation
x = randn(6,1); X = expm(se3_vec(x));

for i = 1:dim
    
    nstdChosen = nstd(1,i);
    for j = 1:N
        
        %Trajectory Generation
        %------------------------------------------------------
        
        
        A = zeros(4,4,numPair);
        B = zeros(4,4,numPair);
        
        for k = 1:numPair       
            B(:,:,k) = expm(se3_vec(randn(6,1)));
            A(:,:,k) = X*B(:,:,k)*X^-1;
        end
%         for k = 1:numPair
%             [A(:,:,k), B(:,:,k)] = ABPair1(X);
%         end
        
        %-------------------------------------------------------
        if  opt == 1
            
            B = sensorNoise(B, gmean, nstdChosen, 1);
            
        elseif opt ==2
            
            [A, X_dist] = A_NoiseX(B, X, gmean, nstdChosen, 1);
            
        end
        
        %% Solution for X
        %-------------------------------------------------------
        X_kron(1:4,1:4,j) = axb_KronSolve2( A, B );
        
        %X_Lie(1:4,1:4,j) = axb_LieGroup( A, B );
        %THETA_hat = X_Lie(1:3,1:3,i);
        
        % when As and Bs are generated by consecutive A and B 
%         if -0.99 > det(THETA_hat) && det(THETA_hat) > - 1.01
%             if markerLie(1,1) == 0
%                 markerLie = [i, j];
%             else
%                 markerLie = [markerLie; i j];
%             end
%             det(THETA_hat);
%         end
        
        X_quat(1:4,1:4,j) = axb_quaternionNoise( A, B );
        
        X_dual(1:4,1:4,j) = axb_dualQuaternion( A, B );
        
        % roterror and tranerror
        %--------------------------------------------------------
        rotErrorKron(i,j) = roterror(X, X_kron(:,:,j));
        tranErrorKron(i,j) = tranerror(X, X_kron(:,:,j));
        
        %rotErrorLie(i,j) = roterror(X, X_Lie(:,:,j));
        %tranErrorLie(i,j) = tranerror(X, X_Lie(:,:,j));
        
        rotErrorQuat(i,j) = roterror(X, X_quat(:,:,j));
        tranErrorQuat(i,j) = tranerror(X, X_quat(:,:,j));
        
        rotErrorDual(i,j) = roterror(X, X_dual(:,:,j));
        tranErrorDual(i,j) = tranerror(X, X_dual(:,:,j));
        
        % error covariance matrix for the twist
        % the 6 parameters for the Lie Group
        %--------------------------------------------------------
        S_kron = errorCovariance(A, B, X_kron(:,:,j));
        
        %S_Lie = errorCovariance(A, B, X_Lie(:,:,j));
        
        S_quat = errorCovariance(A, B, X_quat(:,:,j));
        
        S_dual = errorCovariance(A, B, X_dual(:,:,j));
        
        % trace of the error covariance matrix
        %-------------------------------------------------------
        tr_kron(i,j) = trace(S_kron);
        
        %tr_Lie(i,j) = trace(S_Lie);
        
        tr_quat(i,j) = trace(S_quat);
        
        tr_dual(i,j) = trace(S_dual);
        
        
    end
end

%%
countMarker = 1;
rotErrorLieBar = zeros(dim,1);
tranErrorLieBar = zeros(dim,1);
tr_LieBar = zeros(dim,1);
%
filterOpt = 2;

% calculate the mean of errors of Rotation, Translation & C
% if filterOpt == 1
%     
%     rotErrorLieBar = sum(rotErrorLie,2)/N;
%     tranErrorLieBar = sum(tranErrorLie,2)/N;
%     tr_LieBar = sum(tr_Lie,2)/N;
%     
% elseif filterOpt == 2
%     
%     for i = 1: dim
%         count = 0;
%         for j = 1:N
%             if [i j] == markerLie(countMarker,:)
%                 countMarker = countMarker + 1;
%             else
%                 count = count + 1;
%                 rotErrorLieBar(i) = (rotErrorLieBar(i) + rotErrorLie(i,j));
%                 tranErrorLieBar(i) = (tranErrorLieBar(i) + tranErrorLie(i,j));
%                 tr_LieBar(i) = (tr_LieBar(i) + tr_Lie(i,j));
%                 
%             end
%         end
%         
%         rotErrorLieBar(i) = rotErrorLieBar(i)/count;
%         tranErrorLieBar(i) = tranErrorLieBar(i)/count;
%         tr_LieBar(i) = tr_LieBar(i)/count;
%         
%     end
% end

%%
rotErrorKronBar = sum(rotErrorKron,2)/N;
rotErrorQuatBar = sum(rotErrorQuat,2)/N;
rotErrorDualBar = sum(rotErrorDual,2)/N;

tranErrorKronBar = sum(tranErrorKron,2)/N;
tranErrorQuatBar = sum(tranErrorQuat,2)/N;
tranErrorDualBar = sum(tranErrorDual,2)/N;

tr_kronBar = sum(tr_kron,2)/N;
tr_quatBar = sum(tr_quat,2)/N;
tr_dualBar = sum(tr_dual,2)/N;


%%
figure
plot(nstd,rotErrorKronBar,'c')
hold on
%plot(nstd,rotErrorLieBar,'r')
hold on
plot(nstd,rotErrorQuatBar,'b')
hold on
plot(nstd,rotErrorDualBar,'g')

xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Rotation Error')
title('Rotation Error vs Noise Level')

legend('Kron','Lie*^{1}','Quat','Dual Quat*{2}')


%%
figure
plot(nstd,tranErrorKronBar,'c')
hold on
%plot(nstd,tranErrorLieBar,'r')
hold on
plot(nstd,tranErrorQuatBar,'b')
hold on
plot(nstd,tranErrorDualBar,'g')

xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Translation Error')
title('Translation Error vs Noise Level')

legend('Kron','Lie*^{1}','Quat','Dual Quat*^{2}')


%%
figure
plot(nstd,tr_kronBar,'c')
hold on
%plot(nstd,tr_LieBar,'r')
hold on
plot(nstd,tr_quatBar,'b')
hold on
plot(nstd,tr_dualBar,'g')

xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Trace')
title('Trace of Error Covariance vs Noise Level')

legend('Kron','Lie*^{1}','Quat','Dual Quat*{2}')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Boxplot of the 4 traditional methods
% Boxplot of Dual Quaternion 
% rotation
figure
rotErrorDualBox = rotErrorDual.';
boxplot(rotErrorDualBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Rotation Error')
title('Dual Quaternion Rotation Error vs Noise Level Boxplot')

% translation
figure
tranErrorDualBox = tranErrorDual.';
boxplot(tranErrorDualBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Translation Error')
title('Dual Quaternion Translation Error vs Noise Level Boxplot')
% trace
figure
tr_dualBox = tr_dual.';
boxplot(tr_dualBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Trace')
title('Dual Quaternion Trace of Error Covariance vs Noise Level Boxplot')

%% Boxplot of Dual Quaternion 
% rotation
figure
rotErrorQuatBox = rotErrorQuat.';
boxplot(rotErrorQuatBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Rotation Error')
title('Quaternion Rotation Error vs Noise Level Boxplot')

% translation
figure
tranErrorQuatBox = tranErrorQuat.';
boxplot(tranErrorQuatBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Translation Error')
title('Quaternion Translation Error vs Noise Level Boxplot')
% trace
figure
tr_quatBox = tr_quat.';
boxplot(tr_quatBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Trace')
title('Quaternion Trace of Error Covariance vs Noise Level Boxplot')

%% Boxplot of Dual Quaternion 
% rotation
figure
rotErrorKronBox = rotErrorKron.';
boxplot(rotErrorKronBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Rotation Error')
title('Kronecker Rotation Error vs Noise Level Boxplot')

% translation
figure
tranErrorKronBox = tranErrorKron.';
boxplot(tranErrorKronBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Translation Error')
title('Kronecker Translation Error vs Noise Level Boxplot')
% trace
figure
tr_kronBox = tr_kron.';
boxplot(tr_kronBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Trace')
title('Kronecker Trace of Error Covariance vs Noise Level Boxplot')

%% Boxplot of Dual Quaternion 
% rotation
figure
rotErrorLieBox = rotErrorLie.';
boxplot(rotErrorLieBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Rotation Error')
title('Lie Group Rotation Error vs Noise Level Boxplot')

% translation
figure
tranErrorLieBox = tranErrorLie.';
boxplot(tranErrorLieBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Translation Error')
title('Lie Group Translation Error vs Noise Level Boxplot')
% trace
figure
tr_LieBox = tr_Lie.';
boxplot(tr_LieBox,nstd)
xlabel('\sigma^{2} Noise Level (variance on the X distribution generation)')
ylabel('Trace')
title('Lie Group Trace of Error Covariance vs Noise Level Boxplot')